<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover" />
  <title>Жвач v1.1 — mobile + touch</title>
  <style>
    html, body { height:100%; margin:0; padding:0; background:#fcfcff; font-family: system-ui; touch-action: none; overflow:hidden; }
    #hud { position:fixed; left:calc(env(safe-area-inset-left, 0px) + 12px); top:calc(env(safe-area-inset-top, 0px) + 12px); background:rgba(255,255,255,.9); padding:10px 12px; border-radius:12px; box-shadow:0 6px 20px rgba(0,0,0,.08); font-size:14px; line-height:1.35; z-index:10; }
    #hud kbd { background:#f0f3ff; padding:2px 6px; border-radius:6px; border:1px solid #dfe6ff; font-size:12px }
    #hud .pill { display:inline-block; padding:2px 8px; border-radius:999px; background:#ffe3ef; border:1px solid #ffc6db; font-weight:600; }
    canvas { position:fixed; left:0; top:0; width:100vw; height:100vh; display:block; outline:none; }
  </style>
</head>
<body>
<div id="hud">
  <div class="pill">Жвач — v1.1</div><br/>
  Десктоп: <kbd>←</kbd><kbd>→</kbd> движение, <kbd>↑</kbd> прыжок, <kbd>S</kbd> супер‑липкость, <kbd>R</kbd> рестарт.<br/>
  Мобайл: левый <b>джойстик</b> — движение, <b>тап по правой половине</b> — прыжок.
</div>

<script src="https://cdn.jsdelivr.net/npm/matter-js@0.20.0/build/matter.min.js"></script>
<script>
(function(){
  const { Engine, Render, Runner, World, Bodies, Body, Composite, Constraint, Events, Vector } = Matter;

  // Базовые настройки
  const engine = Engine.create();
  const world = engine.world;
  engine.positionIterations = 4;
  engine.velocityIterations = 3; 
  engine.constraintIterations = 2;
  engine.gravity.y = 1.1;

  // Создаем рендер на весь экран
  const render = Render.create({
    element: document.body,
    engine,
    options: { 
      width: window.innerWidth, 
      height: window.innerHeight, 
      background:'#fbfbff', 
      wireframes:false, 
      pixelRatio: window.devicePixelRatio || 1,
      hasBounds: true 
    }
  });
  Render.run(render);
  Runner.run(Runner.create({ isFixed:true, delta:1000/60 }), engine);

  // Настройка камеры
  const W = 960, H = 540; // базовые размеры мира
  let viewWidth = W;
  let viewHeight = H;

  function updateCamera() {
    const aspect = window.innerWidth / window.innerHeight;
    viewHeight = H;
    viewWidth = H * aspect;
    
    const targetY = gum ? gum.core.position.y : H/2;
    const centerX = W * 0.5;
    
    render.bounds.min.x = centerX - viewWidth * 0.5;
    render.bounds.max.x = centerX + viewWidth * 0.5;
    render.bounds.min.y = targetY - viewHeight * 0.5;
    render.bounds.max.y = targetY + viewHeight * 0.5;
  }

  function resizeCanvas() {
    const canvas = render.canvas;
    const dpr = window.devicePixelRatio || 1;
    
    canvas.style.width = window.innerWidth + 'px';
    canvas.style.height = window.innerHeight + 'px';
    canvas.width = window.innerWidth * dpr;
    canvas.height = window.innerHeight * dpr;
    
    render.options.width = canvas.width;
    render.options.height = canvas.height;
    render.options.pixelRatio = dpr;
    
    updateCamera();
  }

  window.addEventListener('resize', resizeCanvas);
  window.addEventListener('orientationchange', resizeCanvas);
  if (window.visualViewport) {
    window.visualViewport.addEventListener('resize', resizeCanvas);
  }
  resizeCanvas();

  // Границы мира
  World.add(world, [
    Bodies.rectangle(12, 50000, 24, 100000, { isStatic:true, render:{ visible:false } }),
    Bodies.rectangle(W-12, 50000, 24, 100000, { isStatic:true, render:{ visible:false } })
  ]);

  // Модули уровня
  const MOD_H = H;
  let modules = [];
  let modulesSpawned = 0;

  function spawnModule(i){
    const type = (i % 2 === 0) ? 'blue' : 'green';
    const yTop = i * MOD_H;
    const yCenter = yTop + MOD_H * 0.5;
    const bodies = [];
    
    if (type === 'blue'){
      bodies.push(Bodies.rectangle(W*0.5, yCenter, 220, 26, { isStatic:true, render:{ fillStyle:'#bcd1ff' } }));
    } else {
      bodies.push(Bodies.rectangle(W*0.28, yCenter-60, 180, 24, { isStatic:true, angle: 0.15, render:{ fillStyle:'#bfe8c4' } }));
      bodies.push(Bodies.rectangle(W*0.72, yCenter+60, 180, 24, { isStatic:true, angle:-0.15, render:{ fillStyle:'#bfe8c4' } }));
    }
    
    World.add(world, bodies);
    modules.push({ i, type, yTop, yBottom: yTop + MOD_H, bodies });
    modulesSpawned++;
  }

  function ensureModules(){
    const needUpTo = Math.floor((gum ? gum.core.position.y : 0) / MOD_H) + 3;
    while (modulesSpawned <= needUpTo) spawnModule(modulesSpawned);
    
    const minY = render.bounds.min.y;
    for (const m of [...modules]){
      if (m.yBottom < minY - 100){ 
        World.remove(world, m.bodies); 
        modules.splice(modules.indexOf(m),1); 
      }
    }
  }

  // Создание жвачки
  function createGum(x, y, radius=58, segments=12){
    const composite = Composite.create({ label:'GUM' });
    const particles = [];
    const constraints = [];
    const particleR = Math.max(6, Math.round(radius/9));
    const core = Bodies.circle(x, y, Math.max(8, particleR+2), { 
      label:'gum-core', 
      frictionAir:0.02, 
      render:{ visible:false } 
    });
    
    for (let i=0; i<segments; i++){
      const a = (i/segments) * Math.PI * 2;
      const px = x + Math.cos(a) * radius;
      const py = y + Math.sin(a) * radius;
      particles.push(Bodies.circle(px, py, particleR, { 
        label:'gum-node', 
        friction:0.3, 
        restitution:0.15, 
        frictionAir:0.015, 
        collisionFilter:{group:-1}, 
        render:{ visible:false } 
      }));
    }
    
    const kEdge = 0.3, damp = 0.12;
    for (let i=0; i<segments; i++){ 
      const a = particles[i], b = particles[(i+1)%segments]; 
      constraints.push(Constraint.create({ 
        bodyA:a, bodyB:b, 
        length:Vector.magnitude(Vector.sub(a.position,b.position)), 
        stiffness:kEdge, 
        damping:damp 
      })); 
    }
    
    const kRad = 0.22; 
    for (let i=0; i<segments; i++){ 
      const p = particles[i]; 
      constraints.push(Constraint.create({ 
        bodyA:p, bodyB:core, 
        length:Vector.magnitude(Vector.sub(p.position,core.position)), 
        stiffness:kRad, 
        damping:0.1 
      })); 
    }
    
    const kDiag = 0.05; 
    for (let i=0; i<segments; i+=3){ 
      const a = particles[i], b = particles[(i+3)%segments]; 
      constraints.push(Constraint.create({ 
        bodyA:a, bodyB:b, 
        length:Vector.magnitude(Vector.sub(a.position,b.position)), 
        stiffness:kDiag, 
        damping:0.08 
      })); 
    }
    
    Composite.add(composite, [core, ...particles, ...constraints]);
    return { composite, core, particles, constraints, stickyJoints: new Set() };
  }

  let gum = createGum(W*0.2, H*0.2, 58, 12);
  World.add(world, gum.composite);

  // Управление
  const MOVE = 0.0016, AIR_MOVE = 0.0012, JUMP = 0.045;
  const keys = { left:false, right:false };
  
  function applyToCore(fx, fy){ 
    Body.applyForce(gum.core, gum.core.position, {x:fx, y:fy}); 
  }
  
  let jumpReadyAt = 0;
  function tryJump(){ 
    const now = performance.now(); 
    if(now < jumpReadyAt) return; 
    applyToCore(0, -JUMP); 
    jumpReadyAt = now + 160; 
  }

  window.addEventListener('keydown', e => {
    if(['ArrowLeft','ArrowRight','ArrowUp'].includes(e.code)) e.preventDefault();
    if(e.code === 'ArrowLeft') keys.left = true;
    if(e.code === 'ArrowRight') keys.right = true;
    if(e.code === 'ArrowUp') tryJump();
    if(e.code === 'KeyR') reset();
  });
  
  window.addEventListener('keyup', e => {
    if(['ArrowLeft','ArrowRight','ArrowUp'].includes(e.code)) e.preventDefault();
    if(e.code === 'ArrowLeft') keys.left = false;
    if(e.code === 'ArrowRight') keys.right = false;
  });

  // Тач управление
  const joy = { active:false, id:null, baseX:90, baseY:0, curX:90, curY:0, r:70, axisX:0 };
  
  function clamp(v, min, max){ return v < min ? min : (v > max ? max : v); }
  
  function toCanvasCoords(touch){ 
    const rect = render.canvas.getBoundingClientRect(); 
    const x = (touch.clientX - rect.left) * (render.canvas.width / rect.width); 
    const y = (touch.clientY - rect.top) * (render.canvas.height / rect.height); 
    return {x, y}; 
  }
  
  function updateJoy(p){ 
    const dx = p.x - joy.baseX, dy = p.y - joy.baseY; 
    const dist = Math.hypot(dx, dy), max = joy.r; 
    const k = dist > max ? max/dist : 1; 
    joy.curX = joy.baseX + dx * k; 
    joy.curY = joy.baseY + dy * k; 
    joy.axisX = clamp((joy.curX - joy.baseX) / max, -1, 1); 
  }
  
  function endJoy(){ 
    joy.active = false; 
    joy.id = null; 
    joy.curX = joy.baseX; 
    joy.curY = joy.baseY; 
    joy.axisX = 0; 
  }

  function updateJoyPosition() {
    joy.baseY = render.canvas.height - 90;
    joy.curY = joy.baseY;
  }

  render.canvas.addEventListener('touchstart', e => {
    e.preventDefault();
    for(const t of e.changedTouches){ 
      const p = toCanvasCoords(t); 
      const onLeft = (t.clientX < window.innerWidth * 0.5);
      if(!joy.active && onLeft){ 
        joy.active = true; 
        joy.id = t.identifier; 
        updateJoy(p);
      } else { 
        tryJump(); 
      } 
    }
  }, {passive:false});
  
  render.canvas.addEventListener('touchmove', e => {
    e.preventDefault();
    for(const t of e.changedTouches){ 
      if(joy.active && t.identifier === joy.id) updateJoy(toCanvasCoords(t)); 
    }
  }, {passive:false});
  
  function endTouch(e){ 
    e.preventDefault(); 
    for(const t of e.changedTouches){ 
      if(joy.active && t.identifier === joy.id) endJoy(); 
    } 
  }
  
  render.canvas.addEventListener('touchend', endTouch, {passive:false});
  render.canvas.addEventListener('touchcancel', endTouch, {passive:false});

  // Игровой цикл
  Events.on(engine, 'beforeUpdate', () => {
    updateCamera();
    ensureModules();
    updateJoyPosition();
    
    // Движение
    const onGround = gum.core.position.y > H - 60; 
    const f = onGround ? MOVE : AIR_MOVE;
    let axis = 0; 
    if(keys.left) axis -= 1; 
    if(keys.right) axis += 1; 
    axis += joy.axisX; 
    axis = clamp(axis, -1, 1); 
    if(Math.abs(axis) > 0.01) applyToCore(f * axis, 0);
  });

  function reset(){ 
    World.remove(world, gum.composite); 
    gum = createGum(W*0.2, H*0.2, 58, 12); 
    World.add(world, gum.composite); 
  }

  // Отрисовка
  function worldToScreen(v){ 
    const b = render.bounds; 
    const sX = render.options.width / (b.max.x - b.min.x);
    const sY = render.options.height / (b.max.y - b.min.y); 
    return { 
      x: (v.x - b.min.x) * sX, 
      y: (v.y - b.min.y) * sY, 
      sX, sY 
    }; 
  }

  Events.on(render, 'afterRender', () => {
    const ctx = render.context; 
    const b = render.bounds; 
    const height = render.options.height; 
    const sX = render.options.width / (b.max.x - b.min.x); 
    const sY = render.options.height / (b.max.y - b.min.y); 
    const avgScale = (sX + sY) * 0.5;

    // Цвет стен
    const currentIdx = Math.floor(gum.core.position.y / H); 
    const type = (currentIdx % 2 === 0) ? 'blue' : 'green'; 
    const wallColor = (type === 'blue') ? '#d6e1ff' : '#d9f4df';
    ctx.save(); 
    ctx.setTransform(1,0,0,1,0,0); 
    ctx.fillStyle = wallColor; 
    const wallW = 24 * sX; 
    ctx.fillRect(0, 0, wallW, height); 
    ctx.fillRect(render.options.width - wallW, 0, wallW, height); 
    ctx.restore();

    // Оболочка жвачки
    const ptsW = gum.particles.map(p => p.position); 
    const pts = ptsW.map(worldToScreen); 
    const ctrW = gum.core.position; 
    const ctrS = worldToScreen(ctrW);
    
    if(pts.length > 2){
      ctx.save(); 
      ctx.beginPath(); 
      ctx.moveTo(pts[0].x, pts[0].y); 
      for(let i = 1; i < pts.length; i++) ctx.lineTo(pts[i].x, pts[i].y); 
      ctx.closePath();
      
      let avgR = 0; 
      for(let i = 0; i < ptsW.length; i++){ 
        const dx = ptsW[i].x - ctrW.x, dy = ptsW[i].y - ctrW.y; 
        avgR += Math.hypot(dx, dy);
      } 
      avgR /= ptsW.length; 
      const sr = avgR * avgScale;
      
      const g = ctx.createRadialGradient(ctrS.x - sr*0.15, ctrS.y - sr*0.25, sr*0.1, ctrS.x, ctrS.y, sr); 
      g.addColorStop(0, '#ffd3e5'); 
      g.addColorStop(0.6, '#ff9ec2'); 
      g.addColorStop(1, '#ff87b4'); 
      ctx.fillStyle = g; 
      ctx.fill();
      ctx.lineJoin = 'round'; 
      ctx.miterLimit = 2; 
      ctx.lineWidth = 6; 
      ctx.strokeStyle = '#ff9dbf'; 
      ctx.stroke();
      ctx.restore();
    }

    // Лицо
    ctx.save(); 
    const eyeOffset = 14 * avgScale, eyeR = 7 * avgScale, pupilR = 3.2 * avgScale; 
    ctx.fillStyle = '#fff'; 
    ctx.beginPath(); 
    ctx.arc(ctrS.x - eyeOffset, ctrS.y - 10*avgScale, eyeR, 0, Math.PI*2); 
    ctx.fill(); 
    ctx.beginPath(); 
    ctx.arc(ctrS.x + eyeOffset, ctrS.y - 10*avgScale, eyeR, 0, Math.PI*2); 
    ctx.fill(); 
    ctx.fillStyle = '#111'; 
    ctx.beginPath(); 
    ctx.arc(ctrS.x - eyeOffset + 2*avgScale, ctrS.y - 12*avgScale, pupilR, 0, Math.PI*2); 
    ctx.fill(); 
    ctx.beginPath(); 
    ctx.arc(ctrS.x + eyeOffset + 1*avgScale, ctrS.y - 12*avgScale, pupilR, 0, Math.PI*2); 
    ctx.fill(); 
    ctx.strokeStyle = '#78324d'; 
    ctx.lineWidth = 2 * avgScale; 
    ctx.beginPath(); 
    ctx.arc(ctrS.x, ctrS.y, 10*avgScale, 0.15*Math.PI, 0.85*Math.PI); 
    ctx.stroke(); 
    ctx.restore();

    // Джойстик
    if(joy.active) {
      ctx.save(); 
      ctx.setTransform(1,0,0,1,0,0); 
      ctx.globalAlpha = 0.12; 
      ctx.beginPath(); 
      ctx.arc(joy.baseX, joy.baseY, joy.r, 0, Math.PI*2); 
      ctx.fillStyle = '#000'; 
      ctx.fill(); 
      ctx.globalAlpha = 0.35; 
      ctx.beginPath(); 
      ctx.arc(joy.curX, joy.curY, joy.r*0.35, 0, Math.PI*2); 
      ctx.fillStyle = '#000'; 
      ctx.fill(); 
      ctx.globalAlpha = 1; 
      ctx.restore();
    }
  });

  // Декоративные коробки
  for(let i = 0; i < 4; i++){ 
    const b = Bodies.rectangle(540 + i*60, 60 + i*5, 36, 36, { 
      restitution:0.2, 
      friction:0.25, 
      render:{ fillStyle:'#ffd8e7' } 
    }); 
    World.add(world, b); 
  }

})();
</script>
</body>
</html>